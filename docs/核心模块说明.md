# GNTO 核心模块详细说明

本文档详细说明GNTO框架的三个核心模块，以及它们如何协作完成从执行计划到成本预测的完整流程。

## 🏗️ 整体架构

```
执行计划 → NodeEncoder → StructureEncoder → Heads → 成本预测
   ↓           ↓              ↓            ↓        ↓
原始特征    节点向量        计划向量      预测网络   最终结果
```

## 1️⃣ NodeEncoder（节点编码器）

### 功能描述
将执行计划中每个节点的原始特征转换为密集的向量表示。

### 输入输出
- **输入**: `[N, input_dim]` - N个节点的原始特征
- **输出**: `[N, output_dim]` - N个节点的向量表示

### 处理的特征类型

#### 连续特征
```python
continuous_features = [
    "rows",           # 行数
    "ndv",            # 不重复值数量
    "selectivity",    # 选择率
    "io_cost",        # I/O成本
    "cpu_cost",       # CPU成本
    "parallel_degree" # 并行度
]
```

#### 类别特征
```python
categorical_features = {
    "operator_type": 50,    # 算子类型（如SeqScan, HashJoin）
    "join_type": 10,        # 连接类型（如inner, left）
    "index_type": 20,       # 索引类型
    "storage_format": 15,   # 存储格式
    "hint": 30             # 优化器提示
}
```

#### 结构特征
```python
structure_features = [
    "is_blocking",    # 是否阻塞算子
    "is_pipeline",    # 是否流水线算子
    "is_probe",       # 是否探测端
    "is_build",       # 是否构建端
    "stage_id"        # 执行阶段ID
]
```

### 网络结构
```python
# 多层感知机(MLP)结构
input_dim → hidden_dim1 → hidden_dim2 → output_dim
    ↓           ↓            ↓            ↓
   原始特征 → ReLU+Dropout → ReLU+Dropout → 节点向量
```

### 示例代码
```python
from gnto.core.encoders import NodeEncoder

# 创建节点编码器
encoder = NodeEncoder(
    input_dim=150,          # 假设有150维输入特征
    hidden_dims=[256, 128], # 两个隐藏层
    output_dim=64,          # 输出64维节点向量
    dropout=0.1             # 10%的dropout
)

# 编码节点特征
node_features = torch.randn(5, 150)  # 5个节点，每个150维特征
node_vectors = encoder(node_features)  # 输出: [5, 64]
```

## 2️⃣ StructureEncoder（结构编码器/GNN）

### 功能描述
使用图神经网络将所有节点向量和它们之间的连接关系编码为单个计划向量。

### 输入输出
- **输入**: 
  - `nodes`: `[N, node_dim]` - 节点向量（来自NodeEncoder）
  - `edges`: `[2, E]` - 边的连接关系
  - `edge_types`: `[E]` - 边的类型
  - `batch_idx`: `[N]` - 节点所属批次（用于批处理）
- **输出**: 
  - `node_emb`: `[N, hidden_dim]` - 更新后的节点嵌入
  - `plan_emb`: `[B, hidden_dim]` - 计划级嵌入向量

### GNN工作原理

#### 1. 消息传递机制
```python
# 每个节点收集邻居节点的信息
for layer in gnn_layers:
    # 节点i从邻居j收集信息
    message_ij = W * node_j + edge_embedding
    # 聚合所有邻居的消息
    aggregated = aggregate(messages_from_neighbors)
    # 更新节点表示
    node_i = update(node_i, aggregated)
```

#### 2. 支持的GNN类型

**GCN (图卷积网络)**
```python
# 图卷积层
x_new = σ(D^(-1/2) * A * D^(-1/2) * X * W)
```

**GAT (图注意力网络)**
```python
# 注意力机制计算邻居重要性
attention = softmax(LeakyReLU(W * [x_i || x_j]))
x_new = σ(Σ attention_ij * W * x_j)
```

#### 3. 池化策略
将多个节点向量合并为单个计划向量：

```python
# 平均池化
plan_vector = mean(node_vectors)

# 最大池化  
plan_vector = max(node_vectors)

# 注意力池化
attention_weights = softmax(W * node_vectors)
plan_vector = Σ(attention_weights * node_vectors)
```

### 示例代码
```python
from gnto.core.encoders import StructureEncoder

# 创建结构编码器
gnn = StructureEncoder(
    node_dim=64,        # 接收64维节点向量
    hidden_dim=128,     # GNN隐藏层128维
    num_layers=3,       # 3层GNN
    gnn_type="gcn",     # 使用GCN
    pooling="mean"      # 平均池化
)

# 编码计划结构
result = gnn(
    nodes=node_vectors,     # [5, 64] 节点向量
    edges=edge_index,       # [2, 4] 边连接
    edge_types=edge_types,  # [4] 边类型
    batch_idx=batch_idx     # [5] 批次索引
)

plan_vector = result['plan_emb']  # [1, 128] 计划向量
```

## 3️⃣ Heads（预测头）

### 功能描述
将GNN输出的计划向量转换为具体的预测结果，如执行成本、延迟等。

### 输入输出
- **输入**: `[B, plan_emb_dim]` - 计划向量（来自StructureEncoder）
- **输出**: `[B, 1]` - 预测结果（如成本值）

### 支持的预测任务

#### 1. 成本预测（Cost Prediction）
```python
cost_head = RegressionHead(
    input_dim=128,
    hidden_dims=[64, 32],
    output_dim=1,
    output_activation="softplus"  # 确保输出正数
)

predicted_cost = cost_head(plan_vector)  # 预测执行成本
```

#### 2. 延迟预测（Latency Prediction）
```python
latency_head = RegressionHead(
    input_dim=128,
    output_dim=1,
    output_activation="softplus"  # 确保输出正数
)

predicted_latency = latency_head(plan_vector)  # 预测执行时间
```

#### 3. 计划排序（Plan Ranking）
```python
ranking_head = RankingHead(
    input_dim=128,
    output_dim=1
)

ranking_score = ranking_head(plan_vector)  # 计划排序分数
```

### 多任务预测
```python
from gnto.core.heads import Heads

# 创建多任务预测头
heads = Heads(
    plan_emb_dim=128,
    node_emb_dim=128,
    tasks=["cost", "latency", "ranking"],  # 同时预测多个任务
    hidden_dims=[64, 32]
)

# 进行多任务预测
predictions = heads(
    plan_emb=plan_vector,
    node_emb=node_embeddings
)

print(f"预测成本: {predictions['cost']}")
print(f"预测延迟: {predictions['latency']}")  
print(f"排序分数: {predictions['ranking']}")
```

## 🔄 完整数据流

### 步骤详解

```python
# 1. 原始执行计划
plan = {
    "nodes": [
        {"operator_type": "SeqScan", "rows": 10000, "selectivity": 1.0, ...},
        {"operator_type": "Filter", "rows": 5000, "selectivity": 0.5, ...},
        {"operator_type": "HashJoin", "rows": 7500, "selectivity": 1.5, ...}
    ],
    "edges": [
        {"source": 0, "target": 1, "type": "pipeline"},
        {"source": 1, "target": 2, "type": "pipeline"}
    ]
}

# 2. 特征提取和张量化
features = feature_spec.tensorize(plan)
# node_features: [3, 150] - 3个节点，每个150维特征
# edge_index: [2, 2] - 2条边的连接关系
# edge_types: [2] - 边类型

# 3. 节点编码
node_vectors = node_encoder(features.node_features)
# [3, 150] → [3, 64]

# 4. 结构编码（GNN）
structure_output = structure_encoder(
    nodes=node_vectors,
    edges=features.edge_index,
    edge_types=features.edge_types,
    batch_idx=features.batch_idx
)
plan_vector = structure_output['plan_emb']
# [3, 64] → [1, 128]

# 5. 成本预测
predicted_cost = cost_head(plan_vector)
# [1, 128] → [1, 1]
```

## 💡 关键设计思想

### 1. 分层抽象
- **节点级**: 处理单个算子的特征
- **结构级**: 处理算子之间的关系
- **计划级**: 生成整个计划的表示

### 2. 端到端学习
- 三个模块可以联合训练
- 梯度可以从预测头反向传播到节点编码器
- 整个系统针对最终任务进行优化

### 3. 模块化设计
- 每个模块可以独立替换和改进
- 支持不同的GNN架构（GCN、GAT等）
- 支持多种预测任务

### 4. 批处理支持
- 可以同时处理多个执行计划
- 高效的GPU并行计算
- 适合生产环境部署

## 🚀 使用示例

完整的使用示例请参考 `examples/three_modules_demo.py`：

```bash
cd GNTO
python examples/three_modules_demo.py
```

这个示例展示了三个模块如何协作，从原始的执行计划特征一步步转换为最终的成本预测。
