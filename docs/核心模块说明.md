# GNTO æ ¸å¿ƒæ¨¡å—è¯¦ç»†è¯´æ˜

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜GNTOæ¡†æ¶çš„ä¸‰ä¸ªæ ¸å¿ƒæ¨¡å—ï¼Œä»¥åŠå®ƒä»¬å¦‚ä½•åä½œå®Œæˆä»æ‰§è¡Œè®¡åˆ’åˆ°æˆæœ¬é¢„æµ‹çš„å®Œæ•´æµç¨‹ã€‚

## ğŸ—ï¸ æ•´ä½“æ¶æ„

```
æ‰§è¡Œè®¡åˆ’ â†’ NodeEncoder â†’ StructureEncoder â†’ Heads â†’ æˆæœ¬é¢„æµ‹
   â†“           â†“              â†“            â†“        â†“
åŸå§‹ç‰¹å¾    èŠ‚ç‚¹å‘é‡        è®¡åˆ’å‘é‡      é¢„æµ‹ç½‘ç»œ   æœ€ç»ˆç»“æœ
```

## 1ï¸âƒ£ NodeEncoderï¼ˆèŠ‚ç‚¹ç¼–ç å™¨ï¼‰

### åŠŸèƒ½æè¿°
å°†æ‰§è¡Œè®¡åˆ’ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„åŸå§‹ç‰¹å¾è½¬æ¢ä¸ºå¯†é›†çš„å‘é‡è¡¨ç¤ºã€‚

### è¾“å…¥è¾“å‡º
- **è¾“å…¥**: `[N, input_dim]` - Nä¸ªèŠ‚ç‚¹çš„åŸå§‹ç‰¹å¾
- **è¾“å‡º**: `[N, output_dim]` - Nä¸ªèŠ‚ç‚¹çš„å‘é‡è¡¨ç¤º

### å¤„ç†çš„ç‰¹å¾ç±»å‹

#### è¿ç»­ç‰¹å¾
```python
continuous_features = [
    "rows",           # è¡Œæ•°
    "ndv",            # ä¸é‡å¤å€¼æ•°é‡
    "selectivity",    # é€‰æ‹©ç‡
    "io_cost",        # I/Oæˆæœ¬
    "cpu_cost",       # CPUæˆæœ¬
    "parallel_degree" # å¹¶è¡Œåº¦
]
```

#### ç±»åˆ«ç‰¹å¾
```python
categorical_features = {
    "operator_type": 50,    # ç®—å­ç±»å‹ï¼ˆå¦‚SeqScan, HashJoinï¼‰
    "join_type": 10,        # è¿æ¥ç±»å‹ï¼ˆå¦‚inner, leftï¼‰
    "index_type": 20,       # ç´¢å¼•ç±»å‹
    "storage_format": 15,   # å­˜å‚¨æ ¼å¼
    "hint": 30             # ä¼˜åŒ–å™¨æç¤º
}
```

#### ç»“æ„ç‰¹å¾
```python
structure_features = [
    "is_blocking",    # æ˜¯å¦é˜»å¡ç®—å­
    "is_pipeline",    # æ˜¯å¦æµæ°´çº¿ç®—å­
    "is_probe",       # æ˜¯å¦æ¢æµ‹ç«¯
    "is_build",       # æ˜¯å¦æ„å»ºç«¯
    "stage_id"        # æ‰§è¡Œé˜¶æ®µID
]
```

### ç½‘ç»œç»“æ„
```python
# å¤šå±‚æ„ŸçŸ¥æœº(MLP)ç»“æ„
input_dim â†’ hidden_dim1 â†’ hidden_dim2 â†’ output_dim
    â†“           â†“            â†“            â†“
   åŸå§‹ç‰¹å¾ â†’ ReLU+Dropout â†’ ReLU+Dropout â†’ èŠ‚ç‚¹å‘é‡
```

### ç¤ºä¾‹ä»£ç 
```python
from gnto.core.encoders import NodeEncoder

# åˆ›å»ºèŠ‚ç‚¹ç¼–ç å™¨
encoder = NodeEncoder(
    input_dim=150,          # å‡è®¾æœ‰150ç»´è¾“å…¥ç‰¹å¾
    hidden_dims=[256, 128], # ä¸¤ä¸ªéšè—å±‚
    output_dim=64,          # è¾“å‡º64ç»´èŠ‚ç‚¹å‘é‡
    dropout=0.1             # 10%çš„dropout
)

# ç¼–ç èŠ‚ç‚¹ç‰¹å¾
node_features = torch.randn(5, 150)  # 5ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ª150ç»´ç‰¹å¾
node_vectors = encoder(node_features)  # è¾“å‡º: [5, 64]
```

## 2ï¸âƒ£ StructureEncoderï¼ˆç»“æ„ç¼–ç å™¨/GNNï¼‰

### åŠŸèƒ½æè¿°
ä½¿ç”¨å›¾ç¥ç»ç½‘ç»œå°†æ‰€æœ‰èŠ‚ç‚¹å‘é‡å’Œå®ƒä»¬ä¹‹é—´çš„è¿æ¥å…³ç³»ç¼–ç ä¸ºå•ä¸ªè®¡åˆ’å‘é‡ã€‚

### è¾“å…¥è¾“å‡º
- **è¾“å…¥**: 
  - `nodes`: `[N, node_dim]` - èŠ‚ç‚¹å‘é‡ï¼ˆæ¥è‡ªNodeEncoderï¼‰
  - `edges`: `[2, E]` - è¾¹çš„è¿æ¥å…³ç³»
  - `edge_types`: `[E]` - è¾¹çš„ç±»å‹
  - `batch_idx`: `[N]` - èŠ‚ç‚¹æ‰€å±æ‰¹æ¬¡ï¼ˆç”¨äºæ‰¹å¤„ç†ï¼‰
- **è¾“å‡º**: 
  - `node_emb`: `[N, hidden_dim]` - æ›´æ–°åçš„èŠ‚ç‚¹åµŒå…¥
  - `plan_emb`: `[B, hidden_dim]` - è®¡åˆ’çº§åµŒå…¥å‘é‡

### GNNå·¥ä½œåŸç†

#### 1. æ¶ˆæ¯ä¼ é€’æœºåˆ¶
```python
# æ¯ä¸ªèŠ‚ç‚¹æ”¶é›†é‚»å±…èŠ‚ç‚¹çš„ä¿¡æ¯
for layer in gnn_layers:
    # èŠ‚ç‚¹iä»é‚»å±…jæ”¶é›†ä¿¡æ¯
    message_ij = W * node_j + edge_embedding
    # èšåˆæ‰€æœ‰é‚»å±…çš„æ¶ˆæ¯
    aggregated = aggregate(messages_from_neighbors)
    # æ›´æ–°èŠ‚ç‚¹è¡¨ç¤º
    node_i = update(node_i, aggregated)
```

#### 2. æ”¯æŒçš„GNNç±»å‹

**GCN (å›¾å·ç§¯ç½‘ç»œ)**
```python
# å›¾å·ç§¯å±‚
x_new = Ïƒ(D^(-1/2) * A * D^(-1/2) * X * W)
```

**GAT (å›¾æ³¨æ„åŠ›ç½‘ç»œ)**
```python
# æ³¨æ„åŠ›æœºåˆ¶è®¡ç®—é‚»å±…é‡è¦æ€§
attention = softmax(LeakyReLU(W * [x_i || x_j]))
x_new = Ïƒ(Î£ attention_ij * W * x_j)
```

#### 3. æ± åŒ–ç­–ç•¥
å°†å¤šä¸ªèŠ‚ç‚¹å‘é‡åˆå¹¶ä¸ºå•ä¸ªè®¡åˆ’å‘é‡ï¼š

```python
# å¹³å‡æ± åŒ–
plan_vector = mean(node_vectors)

# æœ€å¤§æ± åŒ–  
plan_vector = max(node_vectors)

# æ³¨æ„åŠ›æ± åŒ–
attention_weights = softmax(W * node_vectors)
plan_vector = Î£(attention_weights * node_vectors)
```

### ç¤ºä¾‹ä»£ç 
```python
from gnto.core.encoders import StructureEncoder

# åˆ›å»ºç»“æ„ç¼–ç å™¨
gnn = StructureEncoder(
    node_dim=64,        # æ¥æ”¶64ç»´èŠ‚ç‚¹å‘é‡
    hidden_dim=128,     # GNNéšè—å±‚128ç»´
    num_layers=3,       # 3å±‚GNN
    gnn_type="gcn",     # ä½¿ç”¨GCN
    pooling="mean"      # å¹³å‡æ± åŒ–
)

# ç¼–ç è®¡åˆ’ç»“æ„
result = gnn(
    nodes=node_vectors,     # [5, 64] èŠ‚ç‚¹å‘é‡
    edges=edge_index,       # [2, 4] è¾¹è¿æ¥
    edge_types=edge_types,  # [4] è¾¹ç±»å‹
    batch_idx=batch_idx     # [5] æ‰¹æ¬¡ç´¢å¼•
)

plan_vector = result['plan_emb']  # [1, 128] è®¡åˆ’å‘é‡
```

## 3ï¸âƒ£ Headsï¼ˆé¢„æµ‹å¤´ï¼‰

### åŠŸèƒ½æè¿°
å°†GNNè¾“å‡ºçš„è®¡åˆ’å‘é‡è½¬æ¢ä¸ºå…·ä½“çš„é¢„æµ‹ç»“æœï¼Œå¦‚æ‰§è¡Œæˆæœ¬ã€å»¶è¿Ÿç­‰ã€‚

### è¾“å…¥è¾“å‡º
- **è¾“å…¥**: `[B, plan_emb_dim]` - è®¡åˆ’å‘é‡ï¼ˆæ¥è‡ªStructureEncoderï¼‰
- **è¾“å‡º**: `[B, 1]` - é¢„æµ‹ç»“æœï¼ˆå¦‚æˆæœ¬å€¼ï¼‰

### æ”¯æŒçš„é¢„æµ‹ä»»åŠ¡

#### 1. æˆæœ¬é¢„æµ‹ï¼ˆCost Predictionï¼‰
```python
cost_head = RegressionHead(
    input_dim=128,
    hidden_dims=[64, 32],
    output_dim=1,
    output_activation="softplus"  # ç¡®ä¿è¾“å‡ºæ­£æ•°
)

predicted_cost = cost_head(plan_vector)  # é¢„æµ‹æ‰§è¡Œæˆæœ¬
```

#### 2. å»¶è¿Ÿé¢„æµ‹ï¼ˆLatency Predictionï¼‰
```python
latency_head = RegressionHead(
    input_dim=128,
    output_dim=1,
    output_activation="softplus"  # ç¡®ä¿è¾“å‡ºæ­£æ•°
)

predicted_latency = latency_head(plan_vector)  # é¢„æµ‹æ‰§è¡Œæ—¶é—´
```

#### 3. è®¡åˆ’æ’åºï¼ˆPlan Rankingï¼‰
```python
ranking_head = RankingHead(
    input_dim=128,
    output_dim=1
)

ranking_score = ranking_head(plan_vector)  # è®¡åˆ’æ’åºåˆ†æ•°
```

### å¤šä»»åŠ¡é¢„æµ‹
```python
from gnto.core.heads import Heads

# åˆ›å»ºå¤šä»»åŠ¡é¢„æµ‹å¤´
heads = Heads(
    plan_emb_dim=128,
    node_emb_dim=128,
    tasks=["cost", "latency", "ranking"],  # åŒæ—¶é¢„æµ‹å¤šä¸ªä»»åŠ¡
    hidden_dims=[64, 32]
)

# è¿›è¡Œå¤šä»»åŠ¡é¢„æµ‹
predictions = heads(
    plan_emb=plan_vector,
    node_emb=node_embeddings
)

print(f"é¢„æµ‹æˆæœ¬: {predictions['cost']}")
print(f"é¢„æµ‹å»¶è¿Ÿ: {predictions['latency']}")  
print(f"æ’åºåˆ†æ•°: {predictions['ranking']}")
```

## ğŸ”„ å®Œæ•´æ•°æ®æµ

### æ­¥éª¤è¯¦è§£

```python
# 1. åŸå§‹æ‰§è¡Œè®¡åˆ’
plan = {
    "nodes": [
        {"operator_type": "SeqScan", "rows": 10000, "selectivity": 1.0, ...},
        {"operator_type": "Filter", "rows": 5000, "selectivity": 0.5, ...},
        {"operator_type": "HashJoin", "rows": 7500, "selectivity": 1.5, ...}
    ],
    "edges": [
        {"source": 0, "target": 1, "type": "pipeline"},
        {"source": 1, "target": 2, "type": "pipeline"}
    ]
}

# 2. ç‰¹å¾æå–å’Œå¼ é‡åŒ–
features = feature_spec.tensorize(plan)
# node_features: [3, 150] - 3ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ª150ç»´ç‰¹å¾
# edge_index: [2, 2] - 2æ¡è¾¹çš„è¿æ¥å…³ç³»
# edge_types: [2] - è¾¹ç±»å‹

# 3. èŠ‚ç‚¹ç¼–ç 
node_vectors = node_encoder(features.node_features)
# [3, 150] â†’ [3, 64]

# 4. ç»“æ„ç¼–ç ï¼ˆGNNï¼‰
structure_output = structure_encoder(
    nodes=node_vectors,
    edges=features.edge_index,
    edge_types=features.edge_types,
    batch_idx=features.batch_idx
)
plan_vector = structure_output['plan_emb']
# [3, 64] â†’ [1, 128]

# 5. æˆæœ¬é¢„æµ‹
predicted_cost = cost_head(plan_vector)
# [1, 128] â†’ [1, 1]
```

## ğŸ’¡ å…³é”®è®¾è®¡æ€æƒ³

### 1. åˆ†å±‚æŠ½è±¡
- **èŠ‚ç‚¹çº§**: å¤„ç†å•ä¸ªç®—å­çš„ç‰¹å¾
- **ç»“æ„çº§**: å¤„ç†ç®—å­ä¹‹é—´çš„å…³ç³»
- **è®¡åˆ’çº§**: ç”Ÿæˆæ•´ä¸ªè®¡åˆ’çš„è¡¨ç¤º

### 2. ç«¯åˆ°ç«¯å­¦ä¹ 
- ä¸‰ä¸ªæ¨¡å—å¯ä»¥è”åˆè®­ç»ƒ
- æ¢¯åº¦å¯ä»¥ä»é¢„æµ‹å¤´åå‘ä¼ æ’­åˆ°èŠ‚ç‚¹ç¼–ç å™¨
- æ•´ä¸ªç³»ç»Ÿé’ˆå¯¹æœ€ç»ˆä»»åŠ¡è¿›è¡Œä¼˜åŒ–

### 3. æ¨¡å—åŒ–è®¾è®¡
- æ¯ä¸ªæ¨¡å—å¯ä»¥ç‹¬ç«‹æ›¿æ¢å’Œæ”¹è¿›
- æ”¯æŒä¸åŒçš„GNNæ¶æ„ï¼ˆGCNã€GATç­‰ï¼‰
- æ”¯æŒå¤šç§é¢„æµ‹ä»»åŠ¡

### 4. æ‰¹å¤„ç†æ”¯æŒ
- å¯ä»¥åŒæ—¶å¤„ç†å¤šä¸ªæ‰§è¡Œè®¡åˆ’
- é«˜æ•ˆçš„GPUå¹¶è¡Œè®¡ç®—
- é€‚åˆç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

å®Œæ•´çš„ä½¿ç”¨ç¤ºä¾‹è¯·å‚è€ƒ `examples/three_modules_demo.py`ï¼š

```bash
cd GNTO
python examples/three_modules_demo.py
```

è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº†ä¸‰ä¸ªæ¨¡å—å¦‚ä½•åä½œï¼Œä»åŸå§‹çš„æ‰§è¡Œè®¡åˆ’ç‰¹å¾ä¸€æ­¥æ­¥è½¬æ¢ä¸ºæœ€ç»ˆçš„æˆæœ¬é¢„æµ‹ã€‚
