警告: GNTO模块不可用，将跳过相关演示
GNTO (Graph Neural Tree Optimizer) 演示
基于README.md架构的完整实现
GNTO包信息不可用，但核心组件可以正常演示
================================================================================
GNTO 架构演示 - 逐步处理流程
================================================================================

示例计划 2: Seq Scan
--------------------------------------------------

步骤 1: 预处理 (DataPreprocessor)
输入: 原始JSON风格的计划
输出: TreeNode结构
转换完成:
   - 根节点类型: Seq Scan
   - 子节点数量: 0
   - 额外信息字段: ['Node Type', 'Relation Name', 'Alias', 'Startup Cost', 'Total Cost', 'Plan Rows', 'Plan Width', 'Filter']

树结构可视化:
└── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

树统计信息:
   - 总节点数: 1
   - 最大深度: 0
   - 节点类型分布: {'Seq Scan': 1}

步骤 2: 节点级编码 (Node Encoder)
输入: TreeNode (每个Node的vector为空)
输出: TreeNode (每个Node有自己的node_vector)

简单编码器 (32维输出):

简单编码器 - 树结构 + 向量信息:
============================================================
└── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

简单编码器 - 节点向量详情:
----------------------------------------
节点 1: Seq Scan
  向量维度: torch.Size([32])
  向量值 (前8个): [-1.2807503938674927, -0.49135822057724, 0.34592097997665405, 0.14377349615097046, -0.8161475658416748, -0.3147369623184204, -0.08332288265228271, 1.0138779878616333]
  向量范围: [-1.2808, 1.0488]


标准编码器 (64维输出 - 分块编码):

标准编码器 - 树结构 + 向量信息:
============================================================
└── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

标准编码器 - 节点向量详情:
----------------------------------------
节点 1: Seq Scan
  向量维度: torch.Size([64])
  向量值 (前8个): [-1.0009832382202148, 0.3452850580215454, -0.9129847288131714, 0.19079962372779846, 0.5084603428840637, 0.8421703577041626, 0.3296753764152527, -0.2765524685382843]
  向量范围: [-1.5791, 1.6928]


标准编码器配置:
  算子embedding维度: 32
  统计MLP隐层维度: 16
  谓词特征维度: 8
  输出维度: 64
  词汇表大小: 1

大容量编码器 (128维输出):

大容量编码器 - 树结构 + 向量信息:
============================================================
└── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

向量存储验证:
   - Seq Scan: node_vector 维度 128

步骤 3: 结构级编码 (Tree Encoder)
输入: 带有节点向量的树/DAG
输出: 全局plan embedding

传统树编码器 (统计聚合):
   - 简单编码器 plan embedding: 维度 torch.Size([32])
   - 标准编码器 plan embedding: 维度 torch.Size([64])
   - 大容量编码器 plan embedding: 维度 torch.Size([128])

各编码器的plan embedding对比:
   - 简单: [-1.2807503938674927, -0.49135822057724, 0.34592097997665405, 0.14377349615097046, -0.8161475658416748]
   - 标准: [-1.0009832382202148, 0.3452850580215454, -0.9129847288131714, 0.19079962372779846, 0.5084603428840637]
   - 大容量: [1.2009356021881104, -1.045778751373291, -0.0993678867816925, -0.6489629745483398, 0.9284660220146179]

GNN树编码器:
   - GNN编码失败: name 'GCNTreeEncoder' is not defined

步骤 4: 预测头 (Prediction Head)
输入: plan embedding
输出: 最终预测结果
   - 简单编码器预测: -1.7311
   - 标准编码器预测: 5.3494
   - 大容量编码器预测: 2.9260

==================================================

示例计划 3: Gather
--------------------------------------------------

步骤 1: 预处理 (DataPreprocessor)
输入: 原始JSON风格的计划
输出: TreeNode结构
转换完成:
   - 根节点类型: Gather
   - 子节点数量: 1
   - 额外信息字段: ['Node Type', 'Startup Cost', 'Total Cost', 'Plan Rows', 'Plan Width']

树结构可视化:
└── Gather (Total Cost: 154548.95, Startup Cost: 23540.58, Plan Rows: 567655) [+1 more]
    └── Hash Join (Total Cost: 96783.45, Startup Cost: 22540.58, Plan Rows: 236523) [+2 more]
        ├── Seq Scan (Total Cost: 49166.46, Startup Cost: 0.00, Plan Rows: 649574) [+3 more]
        └── Hash (Total Cost: 15122.68, Startup Cost: 15122.68, Plan Rows: 383592) [+1 more]
            └── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

树统计信息:
   - 总节点数: 5
   - 最大深度: 3
   - 节点类型分布: {'Gather': 1, 'Hash Join': 1, 'Seq Scan': 2, 'Hash': 1}

步骤 2: 节点级编码 (Node Encoder)
输入: TreeNode (每个Node的vector为空)
输出: TreeNode (每个Node有自己的node_vector)

简单编码器 (32维输出):

简单编码器 - 树结构 + 向量信息:
============================================================
└── Gather (Total Cost: 154548.95, Startup Cost: 23540.58, Plan Rows: 567655) [+1 more]
    └── Hash Join (Total Cost: 96783.45, Startup Cost: 22540.58, Plan Rows: 236523) [+2 more]
        ├── Seq Scan (Total Cost: 49166.46, Startup Cost: 0.00, Plan Rows: 649574) [+3 more]
        └── Hash (Total Cost: 15122.68, Startup Cost: 15122.68, Plan Rows: 383592) [+1 more]
            └── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

简单编码器 - 节点向量详情:
----------------------------------------
节点 1: Gather
  向量维度: torch.Size([32])
  向量值 (前8个): [0.3642902374267578, -0.21404963731765747, 0.3344869315624237, -0.3738035261631012, 0.6172773838043213, -0.5118749141693115, -0.3197298049926758, -0.43137815594673157]
  向量范围: [-1.0066, 0.6894]

节点 2: Hash Join
  向量维度: torch.Size([32])
  向量值 (前8个): [0.07199300825595856, 0.19102439284324646, 1.0969101190567017, 0.44455841183662415, 0.28066152334213257, 1.1043339967727661, 0.49113860726356506, 0.052590906620025635]
  向量范围: [-1.3107, 1.1198]

节点 3: Seq Scan
  向量维度: torch.Size([32])
  向量值 (前8个): [0.10200057923793793, -0.034047022461891174, 0.6306915283203125, -0.7325936555862427, 0.3305533230304718, -0.04666459560394287, -0.46521589159965515, -0.9614136219024658]
  向量范围: [-0.9614, 0.6552]

节点 4: Hash
  向量维度: torch.Size([32])
  向量值 (前8个): [-0.10991600900888443, -0.2641202211380005, -0.08687698841094971, 0.08356776088476181, 0.757239043712616, -0.2986147999763489, -0.4373253583908081, -0.8366647958755493]
  向量范围: [-1.0801, 1.2211]

节点 5: Seq Scan
  向量维度: torch.Size([32])
  向量值 (前8个): [0.08643004298210144, -0.05474776029586792, 0.6232727766036987, -0.7704041004180908, 0.2950266897678375, -0.016821682453155518, -0.4886394441127777, -0.9747231006622314]
  向量范围: [-0.9747, 0.6908]


标准编码器 (64维输出 - 分块编码):

标准编码器 - 树结构 + 向量信息:
============================================================
└── Gather (Total Cost: 154548.95, Startup Cost: 23540.58, Plan Rows: 567655) [+1 more]
    └── Hash Join (Total Cost: 96783.45, Startup Cost: 22540.58, Plan Rows: 236523) [+2 more]
        ├── Seq Scan (Total Cost: 49166.46, Startup Cost: 0.00, Plan Rows: 649574) [+3 more]
        └── Hash (Total Cost: 15122.68, Startup Cost: 15122.68, Plan Rows: 383592) [+1 more]
            └── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

标准编码器 - 节点向量详情:
----------------------------------------
节点 1: Gather
  向量维度: torch.Size([64])
  向量值 (前8个): [-2.954252243041992, -0.3104304373264313, 0.3190234899520874, 0.5688767433166504, 0.7709245681762695, 0.21564577519893646, -1.347290277481079, 0.156441792845726]
  向量范围: [-2.9543, 3.2025]

节点 2: Hash Join
  向量维度: torch.Size([64])
  向量值 (前8个): [-3.5961856842041016, -1.076481819152832, 0.5751482248306274, -0.7188026905059814, 1.8192145824432373, -0.38075441122055054, -0.8081449866294861, 0.4164280295372009]
  向量范围: [-3.5962, 3.2734]

节点 3: Seq Scan
  向量维度: torch.Size([64])
  向量值 (前8个): [-2.566162109375, -0.9699539542198181, 0.34675881266593933, 0.8997907042503357, 0.5944582223892212, -0.72034752368927, -0.49488866329193115, 0.31245407462120056]
  向量范围: [-2.5662, 2.3906]

节点 4: Hash
  向量维度: torch.Size([64])
  向量值 (前8个): [-2.3846874237060547, -0.8618293404579163, -0.10793131589889526, 0.19110921025276184, 0.4542939066886902, 0.18954047560691833, -0.6686963438987732, 0.5024824142456055]
  向量范围: [-3.2569, 2.9188]

节点 5: Seq Scan
  向量维度: torch.Size([64])
  向量值 (前8个): [-2.4155449867248535, -0.9323684573173523, 0.32626280188560486, 0.8990890383720398, 0.5550488829612732, -0.7072426080703735, -0.44755303859710693, 0.31187736988067627]
  向量范围: [-2.4155, 2.2947]


标准编码器配置:
  算子embedding维度: 32
  统计MLP隐层维度: 16
  谓词特征维度: 8
  输出维度: 64
  词汇表大小: 4

大容量编码器 (128维输出):

大容量编码器 - 树结构 + 向量信息:
============================================================
└── Gather (Total Cost: 154548.95, Startup Cost: 23540.58, Plan Rows: 567655) [+1 more]
    └── Hash Join (Total Cost: 96783.45, Startup Cost: 22540.58, Plan Rows: 236523) [+2 more]
        ├── Seq Scan (Total Cost: 49166.46, Startup Cost: 0.00, Plan Rows: 649574) [+3 more]
        └── Hash (Total Cost: 15122.68, Startup Cost: 15122.68, Plan Rows: 383592) [+1 more]
            └── Seq Scan (Total Cost: 15122.68, Startup Cost: 0.00, Plan Rows: 383592) [+3 more]

向量存储验证:
   - Gather: node_vector 维度 128
   - Hash Join: node_vector 维度 128
   - Seq Scan: node_vector 维度 128
   - Hash: node_vector 维度 128
   - Seq Scan: node_vector 维度 128

步骤 3: 结构级编码 (Tree Encoder)
输入: 带有节点向量的树/DAG
输出: 全局plan embedding

传统树编码器 (统计聚合):
   - 简单编码器 plan embedding: 维度 torch.Size([32])
   - 标准编码器 plan embedding: 维度 torch.Size([64])
   - 大容量编码器 plan embedding: 维度 torch.Size([128])

各编码器的plan embedding对比:
   - 简单: [0.10295957326889038, -0.0751880556344986, 0.519696831703186, -0.26973503828048706, 0.4561516344547272]
   - 标准: [-2.7833664417266846, -0.8302127718925476, 0.2918524146080017, 0.36801260709762573, 0.8387880325317383]
   - 大容量: [0.11151379346847534, 0.3425728678703308, 0.03667217493057251, -1.069075345993042, -1.2698538303375244]

GNN树编码器:
   - GNN编码失败: name 'GCNTreeEncoder' is not defined

步骤 4: 预测头 (Prediction Head)
输入: plan embedding
输出: 最终预测结果
   - 简单编码器预测: -0.4032
   - 标准编码器预测: -8.2854
   - 大容量编码器预测: 1.8674

==================================================

示例计划 4: Index Scan
--------------------------------------------------

步骤 1: 预处理 (DataPreprocessor)
输入: 原始JSON风格的计划
输出: TreeNode结构
转换完成:
   - 根节点类型: Index Scan
   - 子节点数量: 0
   - 额外信息字段: ['Node Type', 'Relation Name', 'Index Name', 'Startup Cost', 'Total Cost', 'Plan Rows', 'Plan Width', 'Index Cond', 'Filter']

树结构可视化:
└── Index Scan (Total Cost: 8.45, Startup Cost: 0.43, Plan Rows: 1) [+3 more]

树统计信息:
   - 总节点数: 1
   - 最大深度: 0
   - 节点类型分布: {'Index Scan': 1}

步骤 2: 节点级编码 (Node Encoder)
输入: TreeNode (每个Node的vector为空)
输出: TreeNode (每个Node有自己的node_vector)

简单编码器 (32维输出):

简单编码器 - 树结构 + 向量信息:
============================================================
└── Index Scan (Total Cost: 8.45, Startup Cost: 0.43, Plan Rows: 1) [+3 more]

简单编码器 - 节点向量详情:
----------------------------------------
节点 1: Index Scan
  向量维度: torch.Size([32])
  向量值 (前8个): [0.2170179784297943, 0.3049232065677643, -0.06437943875789642, 0.7638811469078064, 0.47992339730262756, -1.0750048160552979, -0.6092163324356079, 0.6794945001602173]
  向量范围: [-1.0912, 1.1228]


标准编码器 (64维输出 - 分块编码):

标准编码器 - 树结构 + 向量信息:
============================================================
└── Index Scan (Total Cost: 8.45, Startup Cost: 0.43, Plan Rows: 1) [+3 more]

标准编码器 - 节点向量详情:
----------------------------------------
节点 1: Index Scan
  向量维度: torch.Size([64])
  向量值 (前8个): [-0.3737267851829529, -0.1700538694858551, -0.300182580947876, 0.4783119857311249, 0.30526670813560486, -0.33695805072784424, 0.13150036334991455, -0.547396183013916]
  向量范围: [-1.5884, 1.2594]


标准编码器配置:
  算子embedding维度: 32
  统计MLP隐层维度: 16
  谓词特征维度: 8
  输出维度: 64
  词汇表大小: 1

大容量编码器 (128维输出):

大容量编码器 - 树结构 + 向量信息:
============================================================
└── Index Scan (Total Cost: 8.45, Startup Cost: 0.43, Plan Rows: 1) [+3 more]

向量存储验证:
   - Index Scan: node_vector 维度 128

步骤 3: 结构级编码 (Tree Encoder)
输入: 带有节点向量的树/DAG
输出: 全局plan embedding

传统树编码器 (统计聚合):
   - 简单编码器 plan embedding: 维度 torch.Size([32])
   - 标准编码器 plan embedding: 维度 torch.Size([64])
   - 大容量编码器 plan embedding: 维度 torch.Size([128])

各编码器的plan embedding对比:
   - 简单: [0.2170179784297943, 0.3049232065677643, -0.06437943875789642, 0.7638811469078064, 0.47992339730262756]
   - 标准: [-0.3737267851829529, -0.1700538694858551, -0.300182580947876, 0.4783119857311249, 0.30526670813560486]
   - 大容量: [-0.0004967749118804932, 0.5632579326629639, -0.40338847041130066, 0.22661830484867096, -0.1640596240758896]

GNN树编码器:
   - GNN编码失败: name 'GCNTreeEncoder' is not defined

步骤 4: 预测头 (Prediction Head)
输入: plan embedding
输出: 最终预测结果
   - 简单编码器预测: 5.7031
   - 标准编码器预测: 0.6672
   - 大容量编码器预测: -0.8608

==================================================

================================================================================
完整端到端GNTO流水线演示
================================================================================
跳过端到端演示：GNTO模块不可用

================================================================================
批量处理演示
================================================================================
跳过批量处理演示：GNTO模块不可用
批量处理需要完整的GNTO流水线支持

================================================================================
演示完成!
================================================================================

使用说明:
   1. 确保安装了requirements.txt中的依赖
   2. GNN功能需要PyTorch和PyTorch Geometric
   3. 没有GNN依赖时会自动回退到传统方法
   4. 可以通过修改示例数据来测试不同的查询计划
